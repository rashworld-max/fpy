# Adapted from: https://docs.python.org/3/reference/grammar.html and the Lark Python grammar

input: (_NEWLINE | _stmt)*

_literal: number | string | boolean

_stmt: _small_stmt [_NEWLINE] | _compound_stmt
_small_stmt: _expr_stmt | assign | pass_stmt | break_stmt | continue_stmt | assert_stmt
_compound_stmt: if_stmt | for_stmt | while_stmt
pass_stmt: "pass"
break_stmt: "break"
continue_stmt: "continue"

_expr_stmt: _expr


assert_stmt: "assert" _expr ["," _expr]

# assignment

assign: _expr [":" _expr] "=" _expr


# loops
for_stmt: "for" var "in" _expr ":" body
while_stmt: "while" _expr ":" body

# branching

if_stmt: "if" _expr ":" body elifs ["else" ":" body]
elifs: elif_*
elif_: "elif" _expr ":" body

body: _NEWLINE _INDENT _stmt+ _DEDENT
scoped_body: _NEWLINE _INDENT _stmt+ _DEDENT

_expr: _test

# logical tests
_test: or_test

?or_test: or_test OR_OP and_test -> binary_op
        | and_test

?and_test: and_test AND_OP not_test -> binary_op
         | not_test

?not_test: NOT_OP not_test -> unary_op
          | comparison

# all comparisons have same precedence
?comparison: comparison COMPARISON_OP range -> binary_op
           | range

?range: sum RANGE_OPERATOR sum
      | sum

?sum: sum ADD_OP term -> binary_op
    | sum SUB_OP term -> binary_op
    | term

?term: term MUL_OP factor -> binary_op
     | term DIV_OP factor -> binary_op
     | term FLOOR_DIV_OP factor -> binary_op
     | term MOD_OP factor -> binary_op
     | factor

?factor: ADD_OP factor -> unary_op # unary plus (identity)
       | SUB_OP factor -> unary_op # unary minus (negation)
       | power

?power: atom_expr POW_OP factor -> binary_op
      | atom_expr

arguments: _expr ("," _expr)*

?atom_expr: atom_expr "(" [arguments] ")" -> func_call
          | atom_expr "[" _expr "]" -> get_item
          | atom_expr "." name -> get_attr
          | atom

?atom: _literal
     | "(" _expr ")"
     | var

var: name

# not used in grammar, but may appear in "node" passed from Parser to Compiler
encoding_decl: name

RANGE_OPERATOR: ".."

number: DEC_NUMBER | FLOAT_NUMBER
string: STRING
boolean: CONST_FALSE | CONST_TRUE

# Other terminals

_NEWLINE: ( /\r?\n[\t ]*/ | COMMENT )+

%ignore /[\t \f]+/  // WS
%ignore /\\[\t \f]*\r?\n/   // LINE_CONT
%ignore COMMENT
%declare _INDENT _DEDENT


# Python terminals

!name: NAME
NAME: /[^\W\d]\w*/
COMMENT: /#[^\n]*/
CONST_TRUE: "True"
CONST_FALSE: "False"
ADD_OP: "+"
SUB_OP: "-"
DIV_OP: "/"
MUL_OP: "*"
FLOOR_DIV_OP: "//"
MOD_OP: "%"
POW_OP: "**"
OR_OP: "or"
AND_OP: "and"
NOT_OP: "not"
COMPARISON_OP: ">" | "<" | "<=" | ">=" | "==" | "!="

STRING: /("(?!"").*?(?<!\\)(\\\\)*?"|'(?!'').*?(?<!\\)(\\\\)*?')/i

# -2 prio so we resolve after floats
DEC_NUMBER.-2:   "1".."9"        ("_"?  "0".."9"                       )*
             |   "0"             ("_"?  "0"                            )* /(?![1-9])/

_SPECIAL_DEC: "0".."9"        ("_"?  "0".."9"                       )*

DECIMAL: "." _SPECIAL_DEC | _SPECIAL_DEC "." _SPECIAL_DEC
_EXP: ("e"|"E") ["+" | "-"] _SPECIAL_DEC
# -1 prio so we resolve the .. syntax in for loop range first
FLOAT_NUMBER.-1: _SPECIAL_DEC _EXP | DECIMAL _EXP?
