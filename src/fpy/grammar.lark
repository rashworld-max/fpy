# Adapted from: https://docs.python.org/3/reference/grammar.html and the Lark Python grammar

input: (_NEWLINE | _toplevel_stmt)*

_literal: number | string | boolean

# Top-level statements: function definitions OR regular statements
# Function definitions can ONLY appear here, not nested in any control structure
_toplevel_stmt: def_stmt | _stmt

# Regular statements (no function definitions allowed)
_stmt: _small_stmt [_NEWLINE] | _compound_stmt
_small_stmt: expr_stmt | assign | pass_stmt | break_stmt | continue_stmt | assert_stmt | return_stmt
_compound_stmt: if_stmt | for_stmt | while_stmt
pass_stmt: "pass"
break_stmt: "break"
continue_stmt: "continue"

?expr_stmt: expr


assert_stmt: "assert" expr ["," expr]

return_stmt: "return" [expr]

# assignment

assign: expr [":" type_expr] "=" expr

parameter: var ":" type_expr ["=" expr]
parameters: parameter ("," parameter)*
def_stmt: "def" var "(" [parameters] ")" ["->" type_expr] ":" block

# loops (cannot contain function definitions since they use stmt_list, not toplevel)
for_stmt: "for" var "in" expr ":" stmt_list
while_stmt: "while" expr ":" stmt_list

# branching (cannot contain function definitions since they use stmt_list, not toplevel)
if_stmt: "if" expr ":" stmt_list elifs ["else" ":" stmt_list]
elifs: elif_*
elif_: "elif" expr ":" stmt_list

# Bodies that cannot contain function definitions
stmt_list: _NEWLINE _INDENT _stmt+ _DEDENT
block: _NEWLINE _INDENT _stmt+ _DEDENT

?expr: _test

# logical tests
_test: or_test

?or_test: or_test OR_OP and_test -> binary_op
        | and_test

?and_test: and_test AND_OP not_test -> binary_op
         | not_test

?not_test: NOT_OP not_test -> unary_op
          | comparison

# all comparisons have same precedence
?comparison: comparison COMPARISON_OP range -> binary_op
           | range

?range: sum RANGE_OPERATOR sum
      | sum

?sum: sum ADD_OP term -> binary_op
    | sum SUB_OP term -> binary_op
    | term

?term: term MUL_OP factor -> binary_op
     | term DIV_OP factor -> binary_op
     | term FLOOR_DIV_OP factor -> binary_op
     | term MOD_OP factor -> binary_op
     | factor

?factor: ADD_OP factor -> unary_op # unary plus (identity)
       | SUB_OP factor -> unary_op # unary minus (negation)
       | power

?power: atom_expr POW_OP factor -> binary_op
      | atom_expr

argument: name "=" expr -> named_argument
        | expr -> positional_argument
arguments: argument ("," argument)*

# Qualified name for types (e.g., Fw.Time, Svc.DpRecord)
# Used in type annotations and return types where only names are allowed
type_expr: name ("." name)*

?atom_expr: atom_expr "(" [arguments] ")" -> func_call
          | atom_expr "[" expr "]" -> index_expr
          | atom_expr "." name -> member_access
          | atom

?atom: _literal
     | "(" expr ")"
     | var

var: name

# not used in grammar, but may appear in "node" passed from Parser to Compiler
encoding_decl: name

RANGE_OPERATOR: ".."

number: DEC_NUMBER | FLOAT_NUMBER
string: STRING
boolean: CONST_FALSE | CONST_TRUE

# Other terminals

_NEWLINE: ( /\r?\n[\t ]*/ | COMMENT )+

%ignore /[\t \f]+/  // WS
%ignore /\\[\t \f]*\r?\n/   // LINE_CONT
%ignore COMMENT
%declare _INDENT _DEDENT


# Python terminals

!name: NAME
NAME: /[^\W\d]\w*/
COMMENT: /#[^\n]*/
CONST_TRUE: "True"
CONST_FALSE: "False"
ADD_OP: "+"
SUB_OP: "-"
DIV_OP: "/"
MUL_OP: "*"
FLOOR_DIV_OP: "//"
MOD_OP: "%"
POW_OP: "**"
OR_OP: "or"
AND_OP: "and"
NOT_OP: "not"
COMPARISON_OP: ">" | "<" | "<=" | ">=" | "==" | "!="

STRING: /("(?!"").*?(?<!\\)(\\\\)*?"|'(?!'').*?(?<!\\)(\\\\)*?')/i

# -2 prio so we resolve after floats
DEC_NUMBER.-2:   "1".."9"        ("_"?  "0".."9"                       )*
             |   "0"             ("_"?  "0"                            )* /(?![1-9])/

_SPECIAL_DEC: "0".."9"        ("_"?  "0".."9"                       )*

DECIMAL: "." _SPECIAL_DEC | _SPECIAL_DEC "." _SPECIAL_DEC
_EXP: ("e"|"E") ["+" | "-"] _SPECIAL_DEC
# -1 prio so we resolve the .. syntax in for loop range first
FLOAT_NUMBER.-1: _SPECIAL_DEC _EXP | DECIMAL _EXP?
